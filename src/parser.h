// Parser verifies if the lexemes generated by scanner complies with the
// TruPL grammar.
// @author Hieu Le
// @version November 6th, 2016

#ifndef PARSER_H
#define PARSER_H

// To print error messages.
#include <iostream>
#include <string>

// The parser needs to access token attributes.
#include "token.h"
#include "keywordtoken.h"
#include "punctoken.h"
#include "reloptoken.h"
#include "addoptoken.h"
#include "muloptoken.h"
#include "idtoken.h"
#include "numtoken.h"
#include "eoftoken.h"
#include "scanner.h"
#include "symbol_table.h"

using namespace std;

class Parser {
 public:
  // Constructs a Parser for a given Scanner.
  explicit Parser(Scanner *the_scanner);

  ~Parser();

  // Checks if the Scanner output generates a valid TruPL program.
  bool parse_program();

  // Returns true if current token is EOF.
  bool done_with_input() const;

 private:
  // Parsers for each non-terminal in TruPL.
  bool parse_decl_list();

  bool parse_variable_decl_list();

  bool parse_variable_decl();

  bool parse_procedure_decl_list();

  bool parse_identifier_list();

  bool parse_identifier_list_prm();

  bool parse_standard_type(expr_type& standard_type_type);

  bool parse_block();

  bool parse_procedure_decl();

  bool parse_procedure_args();

  bool parse_formal_parm_list();

  bool parse_formal_parm_list_hat();

  bool parse_stmt_list();

  bool parse_stmt_list_prm();

  bool parse_stmt();

  bool parse_adhoc_as_pc_tail(expr_type& adhoc_as_pc_tail_type);

  bool parse_if_stmt();

  bool parse_if_stmt_hat();

  bool parse_while_stmt();

  bool parse_print_stmt();

  bool parse_expr_list();

  bool parse_actual_parm_list();

  bool parse_actual_parm_list_hat();

  bool parse_expr(expr_type& expr_type_result);

  bool parse_expr_hat(expr_type& expr_hat_type);

  bool parse_simple_expr(expr_type& simple_expr_type);

  bool parse_simple_expr_prm(expr_type& simple_expr_prm_type);

  bool parse_term(expr_type& term_type);

  bool parse_term_prm(expr_type& term_prm_type);

  bool parse_factor(expr_type& factor_type);

  bool parse_sign(expr_type& sign_type);

  // The lexical analyzer
  Scanner *lex;
  // The current token the parser is looking at
  Token *word;

  /* Print out a parse error message:
	 
     "Parse error: Expected *expected*, found *found*."

     This method should delete the string after it has printed the
     error message. */
  void parse_error(string *expected, Token *found) const;

  // Other helper functions that you may define

  // Advance the current token.
  void advance();

  /*********** Semantial Analysis **********/
  // Name of the environment we are currently parsing.
  string *current_env;
  // Name of the environment of the main program.
  string *main_env;
  // Potential procedure name when examining a procedure call.
  string *procedure_name;
  // Position of an actual parameter in a procedure call.
  int actual_parm_position;
  // Position of a formal paramter in a procedure definition.
  int formal_parm_position;
  // A Boolean value that is true only when parsing a formal parameter list.
  bool parsing_formal_parm_list;

  // Symbol table.
  Symbol_Table stab;

  /* These functions are for signalling semantic errors.  None of
     them return - they exit and terminate the compilation.

     Identifier has been define twice.
  */
  void multiply_defined_identifier(string *id) const;

  // Identifier is undeclared.
  void undeclared_identifier(string *id) const;

  // Type error:  a single type was expected.
  void type_error(const expr_type expected,  const expr_type found) const;

  // Type error: one of two types was expected.
  void type_error(const expr_type expected1, const expr_type expected2,
                  const expr_type found) const;

  // Intended for unit tests.
  friend class ParserTest_ParseVariableDecl_Test;
  friend class ParserTest_ParseBlock_Test;
  friend class ParserTest_ParseProcedureDecl_Test;
  friend class ParserTest_ParseStmt_Test;
  friend class ParserTest_ParseIfStmt_Test;
  friend class ParserTest_ParseWhileStmt_Test;
  friend class ParserTest_ParsePrintStmt_Test;
  friend class ParserTest_ParseExpression_Test;
  friend class ParserTest_ParseTerm_Test;
  friend class ParserTest_ParseFactor_Test;
  friend class ParserTest_ParseSign_Test;
};

#endif
